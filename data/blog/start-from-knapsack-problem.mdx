---
title: '从背包问题开始解决动态规划'
date: '2021-11-21'
tags: ['Algorithm', 'Dynamic programming']
draft: false
summary: '背包九讲是对于动态规划的算法问题的很好的总结和归纳'
---

# TODO

## TODO

```
/**
 * 01背包
 * 有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是 Ci1，得到的价值是 Wi。
   求解将哪些物品装入背包可使价值总和最大。
   N == costs.length == values.length
 * @param {Number} v 
 * @param {Array} costs 
 * @param {Array} values 
 */
function maxValueIn01Pack(V, costs = [], values = []) {
    let dp = new Array(V + 1).fill(0), //dp[x]表示背包占用x体积能装下的最大的价值
        len = costs.length;
    for (let i = 0; i < len; i++) {
        for (let j = V; j >= costs[i]; j--) {
            //对于每一种占用的情况考虑那或者是不拿
            if (j - costs[i] >= 0)
                dp[j] = Math.max(dp[j], dp[j - costs[i]] + values[i]);
        }
    }
    return Math.max(...dp);
}

// console.log(maxValueIn01Pack(5, [1, 2, 3, 2, 4, 2, 1], [1, 2, 2, 4, 6, 2, 3])); //9

/**
 * 完全背包
 * 有 N 件物品和一个容量为 V 的背包。每种物品都有无限件可用。放入第 i 件物品耗费的费用是 Ci1，得到的价值是 Wi。
   求解将哪些物品装入背包可使价值总和最大。
   N == costs.length == values.length
 * @param {Number} v 
 * @param {Array} costs 
 * @param {Array} values 
 */
function maxValueInCompletelyPack(V, costs = [], values = []) {
    let dp = new Array(V + 1).fill(0), //dp[x]表示背包占用x体积能装下的最大的价值
        len = costs.length;
    for (let i = 0; i < len; i++) {
        //和01变化之处, 正方向使得物品有无限件可用的可能
        for (let j = costs[i]; j <= V; j++) {
            if (j - costs[i] >= 0)
                dp[j] = Math.max(dp[j], dp[j - costs[i]] + values[i]);
        }
    }
    return Math.max(...dp);
}

// console.log(
//     maxValueInCompletelyPack(5, [1, 2, 3, 2, 4, 2], [1, 2, 2, 4, 6, 2]) //9
// );

/**
 * 多重背包
 * 有 N 种物品和一个容量为 V 的背包。第 i 种物品最多有 Mi 件可用，每件耗费的
    空间是 Ci，价值是 Wi。求解将哪些物品装入背包可使这些物品的耗费的空间总和不超
    过背包容量，且价值总和最大。
 * @param {Number} v 
 * @param {Array} costs 
 * @param {Array} quantities 
 * @param {Array} values 
 */
function maxValueInMultiplePack(V, costs = [], quantities = [], values = []) {
    let dp = new Array(V + 1).fill(0), //dp[x]表示背包占用x体积能装下的最大的价值
        len = costs.length;
    //类似01背包
    for (let i = 0; i < len; i++) {
        for (let j = V; j >= costs[i]; j--) {
            //和01背包的不同在于 有了数量的限制 遍历每种选择的情况
            for (let num = 1; num <= quantities[i]; num++) {
                if (j - num * costs[i] >= 0) {
                    dp[j] = Math.max(
                        dp[j],
                        dp[j - num * costs[i]] + num * values[i]
                    );
                }
            }
        }
    }
    return Math.max(...dp);
}

// console.log(
//     maxValueInMultiplePack(
//         9,
//         [1, 2, 3, 2, 4, 2],
//         [1, 1, 1, 2, 1, 1],
//         [1, 2, 2, 4, 6, 3]
//     )
// ); //15

/**
 * 混合背包
 * 如果将前面1、2、3中的三种背包问题混合起来。也就是说，有的物品只可以取一
    次（01 背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限
    （多重背包）。应该怎么求解呢？
 * @param {Number} v 
 * @param {Array} costs 
 * @param {Array} quantities 'o' 表示只有一个 'a' 表示任意数量 数字表示取的次数上限
 * @param {Array} values 
 */
function maxValueInMixedPack(V, costs = [], quantities = [], values = []) {
    let dp = new Array(V + 1).fill(0), //dp[x]表示背包占用x体积能装下的最大的价值
        len = costs.length;
    for (let i = 0; i < len; i++) {
        if (quantities[i] === 'o') {
            //01背包
            for (let j = V; j >= costs[i]; j--) {
                if (j - costs[i] >= 0)
                    dp[j] = Math.max(dp[j], dp[j - costs[i]] + values[i]);
            }
        } else if (quantities[i] === 'a') {
            //完全背包
            for (let j = costs[i]; j <= V; j++) {
                if (j - costs[i] >= 0)
                    dp[j] = Math.max(dp[j], dp[j - costs[i]] + values[i]);
            }
        } else {
            //多重背包
            for (let j = V; j >= costs[i]; j--) {
                for (let num = 1; num <= quantities[i]; num++) {
                    if (j - num * costs[i] >= 0) {
                        dp[j] = Math.max(
                            dp[j],
                            dp[j - num * costs[i]] + num * values[i]
                        );
                    }
                }
            }
        }
    }
    return Math.max(...dp);
}

// console.log(
//     maxValueInMixedPack(
//         9,
//         [1, 2, 3, 2, 4, 2],
//         [1, 1, 1, 'o', 'a', 1],
//         [1, 2, 2, 4, 6, 3]
//     )
// ); //14

/**
 * 二维费用的背包问题
 * 二维费用的背包问题是指：对于每件物品，具有两种不同的费用，选择这件物品必
    须同时付出这两种费用。对于每种费用都有一个可付出的最大值（背包容量）。问怎样
    选择物品可以得到最大的价值。
    设第 i 件物品所需的两种费用分别为 Ci 和 Di。两种费用可付出的最大值（也即两
    种背包容量）分别为 V 和 U。物品的价值为 Wi。
 * @param {Number} V
 * @param {Number} U
 * @param {Array} costsV 
 * @param {Array} costsU
 * @param {Array} values 
 */
function maxValueInDoubleCostPack(V, U, costsV = [], costsU = [], values = []) {
    let dp = new Array(V + 1).fill(0).map(x => new Array(U + 1).fill(0)),
        //dp[x][y]表示背包占用x体积(V)和y体积(U)能装下的最大的价值
        len = costsV.length;
    for (let i = 0; i < len; i++) {
        for (let k = U; k >= costsU[i]; k--) {
            for (let j = V; j >= costsV[i]; j--) {
                if (j - costsV[i] >= 0 && k - costsU[i] >= 0) {
                    dp[j][k] = Math.max(
                        dp[j][k],
                        dp[j - costsV[i]][k - costsU[i]] + values[i]
                    );
                }
            }
        }
    }
    let res = 0;
    for (let x of dp) {
        res = Math.max(res, ...x);
    }
    return res;
}

// console.log(maxValueInDoubleCostPack(4, 6, [1, 2, 3], [1, 1, 2], [1, 3, 5])); //6

/**
 * 分组的背包问题
 *  有 N 件物品和一个容量为 V 的背包。第 i 件物品的费用是 Ci，价值是 Wi。这些
    物品被划分为 K 组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包
    可使这些物品的费用总和不超过背包容量，且价值总和最大。
 * @param {Number} V
 * @param {Array} costs  
 * @param {Array} values 
 */
function maxValueInGroupPack(V, costs = [], values = []) {
    let dp = new Array(V + 1).fill(0), //dp[x]表示背包占用x体积能装下的最大的价值
        len = costs.length;
    for (let i = 0; i < len; i++) {
        for (let j = V; j >= 0; j--) {
            for (let k = 0; k < costs[i].length; k++) {
                //对于每一种占用的情况考虑那或者是不拿
                if (j - costs[i][k] >= 0)
                    dp[j] = Math.max(dp[j], dp[j - costs[i][k]] + values[i][k]);
            }
        }
    }
    return Math.max(...dp);
}

// console.log(
//     maxValueInGroupPack(
//         6,
//         [
//             [1, 2, 3],
//             [1, 2, 3],
//             [1, 4],
//         ],
//         [
//             [2, 1, 4],
//             [1, 1, 3],
//             [3, 7],
//         ]
//     ) //10
// );
```